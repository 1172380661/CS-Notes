###池化技术
常用的几种池化技术及配置参数：  
druid  
1. initialSize初始化连接数量  
2. maxActive最大连接池数量  
3. minIdle最小连接池数量  
tomcat线程池  
1. acceptCount等待队列大小 ，当Tomcat没有可用空闲线程处理连接请求时，新来的连接请求将放入等待队列中。当队列超过acceptCount时，后续的连接请求就会被拒绝。  
2. maxThreads线程池最大线程数，tomcat能创建来处理请求的最大线程数，当线程池空闲一段时间后会释放到只保留minSpareThreads个线程。  
3. maxSpareThreads最大空闲线程数，在最大空闲时间内活跃过，但现在处于空闲，若空闲时间大于最大空闲时间，则回收，小于则继续存活，等待被调度。  
4. minSpareThreads最小空闲线程数，无论如何都会存活的最小线程数。  
5. maxIdleTime最大空闲时间，超过这个空闲时间，且线程数大于最小空闲数的，都会被回收。

##redis
###为什么使用redis 
- 从性能方面考虑，redis是内存缓存所以访问速度比传统的关系型数据库要快。
- 从并发程度上考虑，如果大量请求都需要连接数据库进行访问可能会造成数据库连接异常。使用redis可以进行一个缓冲，部分有缓存的数据直接从redis中获取。
###redis的数据类型及应用场景
- string：可以把对象变成json格式传入。也可以直接做简单的set/get和数据增加减少操作。
- list:存放多个string,使用List的数据结构，可以做简单的消息队列的功能，例如限时抢购、秒杀等记录商品数量变化。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。
- set:存放多个string但是不允许重复，可以进行全局的去重以及交集并集等运算
- hash：存放多个key-value可以将对象写成key-value的形式存入hash
- sorted set:元素按照一个权重参数进行排列，可以做排行榜等应用
###redis的缺点
- 会造成数据一致性问题
缓存更新策略：
读取数据时，先查缓存，如果有缓存则直接返回，如果没有则读数据库，并将结果存入到缓存中。
更新数据时，不要选择将同时更新缓存和数据库。
- 缓存雪崩问题
大量缓存在同一时间失效，同时都去访问数据库。导致数据库出现连接异常  
解决方案：在设置缓存过期时间时，给定一个随机值避免集体失效
- 缓存击穿问题  
- 缓存的并发竞争问题  
同时有多个子系统去set一个key值。  
将set操作串行进行
###单线程的redis为什么这么快
1. 纯内存操作  
2. 单线程操作，避免了频繁的上下文切换  
3. 采用了 非阻塞I/O多路复用机制
###redis的过期策略，内存淘汰机制
redis采用的是定期删除+惰性删除策略  
redis默认每隔100ms随机抽取检查key是否过期如果过期则删除。这样会导致许多key在过期时间到达之后没有删除于是惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
内存淘汰机制是指，当内存中不足以放入新数据时，选择删除什么key
 