## 概述 ##
集合框架主要分为 Collection 和 Map 两大类。Collection 存储的都是单个对象，而 Map 存储KV结构的对象。  
Collection 可以分为 list 和 set 两种，set 意为集合，也就是说 set是不允许重复的，而 list允许重复。
## ArrayList ##
#### 构造方法 ####
ArrayList有3个构造方法  

    //EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 
	都指向new Object[0];
	//DEFAULT_CAPACITY 容量大小为10
    public ArrayList(int paramInt){
	    if (paramInt > 0) {
	      elementData = new Object[paramInt];
	    } else if (paramInt == 0) {
	      elementData = EMPTY_ELEMENTDATA;
	    } else {
	      throw new IllegalArgumentException("Illegal Capacity: " + paramInt);
	    }
    }
      
    public ArrayList(){
    	elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }  
      
    public ArrayList(Collection<? extends E> paramCollection){
	    elementData = paramCollection.toArray();
	    if ((size = elementData.length) != 0){
	    	if (elementData.getClass() != Object[].class) {
	    	elementData = Arrays.copyOf(elementData, size, Object[].class);
	    	}
	    } else {
	      elementData = EMPTY_ELEMENTDATA;
	    }
    }
可以看出3个构造方法都是在对 elementData 这一字段进行初始化设置。那么 elementData 到底是什么呢？ 它是 ArrayList 的真正实现 ，一个  Object[] 对象。 它被transient所修饰，因为 elementData 数组不一定会被全部填充，所有在对它进行序列化时要特殊处理。

    transient Object[] elementData;
#### add ####
在 add 元素时要判断 elementData 是否有足够的空间，如果空间不足则需要进行扩容。

    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);//容量变为原来的1.5倍
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
#### remove ####
先确定 index 是否越界，之后 copy 数组

    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
#### 线程安全 ####

    List<String> synList = Collections.synchronizedList(list);
	//CopyOnWriteArrayList 使用 ReentrantLock 来保证线程安全
	List<String> list = new CopyOnWriteArrayList<>();
## LinkedList ##
#### 基本结构 ####
LinkedList 中含有一个静态内部类 Node，它规定了链节点的基本结构。 first，last 用来指向链表的头部和尾部。
	
	public class LinkedList<E> extends AbstractSequentialList<E>
	implements List<E>, Deque<E>, Cloneable, Serializable
	{
		transient int size = 0;
		transient Node<E> first;
		transient Node<E> last;
	}
	private static class Node<E>
	{
		E item;
		Node<E> next;
		Node<E> prev;
		
		Node(Node<E> paramNode1, E paramE, Node<E> paramNode2)
		{
			item = paramE;
			next = paramNode2;
			prev = paramNode1;
		}
	}
LinkedList 既可以当 list 使用，也可以当栈或队列使用。  
它的 add, set, remove 方法和 ArrayList 类似区别在于是用链表来实现的。

	// Deque operations
	public void push(E paramE)
	{
		addFirst(paramE);
	}
	
	public E pop()
	{
		return (E)removeFirst();
	}
	// Queue operations.
	public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
    }

push 和 pop 的实质是在添加头节点和删除头节点。
## hashMap ##
hashMap内部使用 Node 来维持KV数据结构。  

      static class Node<K, V>
	    implements Map.Entry<K, V>
	  {
	    final int hash;
	    final K key;
	    V value;
	    Node<K, V> next;
	}
并且内部维护了一个 Node 数组。  

    transient Node<K, V>[] table;
#### put ####
先根据 key 的 hash 来查找对应的下标，如果当前下标没有元素则直接插入。

    if ((p = tab[i = (n - 1) & hash]) == null)//i 就是对应下标
        tab[i] = newNode(hash, key, value, null);
如果当前下标的元素等于要 put 的元素，则直接覆盖。

    if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
        e = p; 
如果当前下标不等，遍历链表，如果链表中没有和对应值相等的元素，将节点添加到尾部。如果有覆盖该节点。

    for (int binCount = 0; ; ++binCount) {
        if ((e = p.next) == null) {
            p.next = newNode(hash, key, value, null);
            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                treeifyBin(tab, hash);
            break;
        }
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            break;
        p = e;
    } 
由于插入元素时并不是按照数组元素来插入，所以 hashMap 无法根据插入顺序来进行遍历遍历。  
## linkedHashMap ##
linkedHashMap 中的 Entry 继承了 HashMap.Node，并且新添加了 before 和 after两个指针。

      static class Entry<K, V>
	    extends HashMap.Node<K, V>
	  {
	    Entry<K, V> before;
	    Entry<K, V> after;
	    
	    Entry(int paramInt, K paramK, V paramV, HashMap.Node<K, V> paramNode)
	    {
	      super(paramK, paramV, paramNode);
	    }
	  }
linkedHashMap 利用 Entry 维护了一个双向链表，并使用 head 指向链表的头部， tail 指向链表的尾部。

	transient Entry<K, V> head;
	transient Entry<K, V> tail;
	final boolean accessOrder;

当 accessOrder 为 false 的话，链表将按照插入顺序排序，遍历顺序同样也是元素插入的顺序。  
如果 accessOrder 为 true 则每次进行 get 操作会将 get 的结点放到链表的尾部，遍历顺序就变成了最近最少使用（LRU）顺序。  

linkedHashMap 还可以用来构建 LRU缓存，只需要重写 removeEldestEntry即可。  

    class LRUCache<K, V> extends LinkedHashMap<K, V> {
	    private static final int MAX_ENTRIES = 3;
	
	    protected boolean removeEldestEntry(Map.Entry eldest) {
	        return size() > MAX_ENTRIES;
	    }
	
	    LRUCache() {
	        super(MAX_ENTRIES, 0.75f, true);
	    }
	}
## ConCurrentHashMap ##