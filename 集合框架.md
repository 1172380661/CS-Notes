## ArrayList ##
#### 构造方法 ####
ArrayList有3个构造方法  

    \\EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 都指向new Object[0];
      public ArrayList(int paramInt)
      {
	    if (paramInt > 0) {
	      elementData = new Object[paramInt];
	    } else if (paramInt == 0) {
	      elementData = EMPTY_ELEMENTDATA;
	    } else {
	      throw new IllegalArgumentException("Illegal Capacity: " + paramInt);
	    }
      }
      
      public ArrayList()
      {
    	elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
      }  
      
      public ArrayList(Collection<? extends E> paramCollection)
      {
	    elementData = paramCollection.toArray();
	    if ((size = elementData.length) != 0)
	    {
	      if (elementData.getClass() != Object[].class) {
	    elementData = Arrays.copyOf(elementData, size, Object[].class);
	      }
	    }
	    else {
	      elementData = EMPTY_ELEMENTDATA;
	    }
      }
可以看出3个构造方法都是在对 elementData 这一字段进行初始化设置。那么 elementData 到底是什么呢？ 它是 ArrayList 的真正实现 ，一个  Object[] 对象。 它被transient所修饰，因为 elementData 数组不一定会被全部填充，所有在对它进行序列化时要特殊处理。

    transient Object[] elementData;
#### add ####
#### remove set ####
#### 快速失败 ####
#### 序列化 ####
#### 线程安全 ####

    List<String> synList = Collections.synchronizedList(list);
	//CopyOnWriteArrayList 使用 ReentrantLock 来保证线程安全
	List<String> list = new CopyOnWriteArrayList<>();
## LinkedList ##
#### 基本结构 ####
LinkedList 中含有一个静态内部类 Node，它规定了链节点的基本结构。 first，last 用来指向链表的头部和尾部。
	
	public class LinkedList<E> extends AbstractSequentialList<E>
	implements List<E>, Deque<E>, Cloneable, Serializable
	{
		transient int size = 0;
		transient Node<E> first;
		transient Node<E> last;
	}
	private static class Node<E>
	{
		E item;
		Node<E> next;
		Node<E> prev;
		
		Node(Node<E> paramNode1, E paramE, Node<E> paramNode2)
		{
			item = paramE;
			next = paramNode2;
			prev = paramNode1;
		}
	}
LinkedList 既可以当 list 使用，也可以当栈或队列使用。  
它的 add, set, remove 方法和 ArrayList 类似区别在于是用链表来实现的。

	public void push(E paramE)
	{
		addFirst(paramE);
	}
	
	public E pop()
	{
		return (E)removeFirst();
	}
push 和 pop 的实质是在添加头节点和删除尾节点。
## hashMap ##
hashMap内部使用 Node 来维持KV数据结构。  

      static class Node<K, V>
	    implements Map.Entry<K, V>
	  {
	    final int hash;
	    final K key;
	    V value;
	    Node<K, V> next;
	}
并且内部维护了一个 Node 数组。  

    transient Node<K, V>[] table;
当调用 put方法后，会根据 key 值的 hash 进行取留余数来判断存储到那个数组位置。  
由于插入元素时并不是按照数组元素来插入所以， hashMap 无法根据插入顺序来进行遍历遍历。  
## linkedHashMap ##  
linkedHashMap 中的 Entry 继承了 HashMap.Node，并且新添加了 before 和 after两个指针。

      static class Entry<K, V>
	    extends HashMap.Node<K, V>
	  {
	    Entry<K, V> before;
	    Entry<K, V> after;
	    
	    Entry(int paramInt, K paramK, V paramV, HashMap.Node<K, V> paramNode)
	    {
	      super(paramK, paramV, paramNode);
	    }
	  }
linkedHashMap 利用 Entry 维护了一个双向链表，并使用 head 指向链表的头部， tail 指向链表的尾部。

	transient Entry<K, V> head;
	transient Entry<K, V> tail;
	final boolean accessOrder;

当 accessOrder 为 false 的话，链表将按照插入顺序排序。遍历顺序同样也是元素插入的顺序。如果 accessOrder 为 true 则每次进行 get 操作会将 get 的结点放到链表的尾部，遍历顺序就变成了最近最少使用（LRU）顺序。  

linkedHashMap 还可以用来构建 LRU缓存，只需要重写 removeEldestEntry即可。  

    class LRUCache<K, V> extends LinkedHashMap<K, V> {
	    private static final int MAX_ENTRIES = 3;
	
	    protected boolean removeEldestEntry(Map.Entry eldest) {
	        return size() > MAX_ENTRIES;
	    }
	
	    LRUCache() {
	        super(MAX_ENTRIES, 0.75f, true);
	    }
	}