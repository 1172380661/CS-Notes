## JVM内存区域 ##
JVM内存可以分为5部分。分别是程序计数器、虚拟机栈、本地方法栈、堆、方法区。
#### 程序计数器 ####
程序计数器是线程私有的，它记录当前线程正在执行的指令码地址。如果正在执行的方法是本地方法则值为空。
#### 虚拟机栈 ####
虚拟机栈是线程私有的，存放当前线程的方法调用。也就是方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。每个栈帧中都含有局部变量表、操作数栈、动态连接、方法返回地址和附加信息。  
1. 局部变量表  
2. 操作数栈  
3. 动态连接实质上是指向其它方法的引用。在.class文件中所有对方法的引用都是字面量，而在类加载的第一阶段，有一部分字面量会变成直接引用。另一部分会保存在栈帧中等到运行时才转化为直接引用。  
4. 方法返回地址：当一个方法被执行后有两种方式退出这个方法。  
一是执行引擎遇到一个方法返回指令这叫正常完成出口(Normal Method Invocation Completion)  
二是方法在执行过程中遇到了异常，且在这个方法中没有进行处理，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。  
5. 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。  
在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。
#### 本地方法栈 ####
本地方法栈和虚拟机栈类似，区别在于本地方法栈用于执行本地方法。
#### 堆 ####
堆中存放了对象的实例信息。它也是垃圾收集的主要区域。  
现代的垃圾收集器都采用分代收集算法，可以将堆分为新生代（Young Generation）和老年代（Old Generation）两块。  
可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。
#### 方法区 ####
用于存在已经被加载的类信息、静态变量、常量、即时编译器编译后的代码等数据。  
方法区也被称为永久代，因为方法区中的信息几乎不会被垃圾回收期进行回收。在 Java8 之后方法区使用元空间来实现，它位于本地内存中，而不是虚拟机内存中。  
方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
#### 运行时常量池 ####
运行时常量池是方法区的一部分，Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。  
在 JDK1.6之前 String Pool也存在常量池中，JDK1.7之后 String Pool被存放在了堆中。

    str.intern();//将字符串放进 String Pool中。
#### 直接内存 ####
在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。
## 垃圾回收 ##
垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。
#### 引用计数法 ####
为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。
#### 可达性分析算法 ####
引入了 GC Root 的概念，只有被 GC Root 所引用的对象才不会被回收。  
GC Root包含：  
1. 虚拟机栈中的局部变量表。  
2. 本地方法栈中JNI所引用的变量。  
3. 方法区中的静态变量和常量。  
和引用计数法相比减少了堆中对象的引用。
#### 方法区的回收 ####
方法区的回收主要包括对常量池的回收和对类的卸载。  
类的卸载在大量使用反射和动态代理的场景中比较重要，不然会造成OOM。  
类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：  
1. 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。  
2. 加载该类的 ClassLoader 已经被回收。  
3. 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
#### finalize() ####
实现了finalize()方法的类，如果在finalize()方法中重新获得引用，则可以逃脱一次垃圾回收。但finalize()只生效一次。
#### 引用类型 ####
Java 中包含4中引用：强引用、软引用、弱引用、虚引用。  
有强引用的对象不会被回收。  
软引用的对象在内存不够时回收。
弱引用在下一次 GC 时回收。  
虚引用只是在对象被 GC 时获得一个提醒。

	Object obj = new Object();    
    SoftReference<Object> sf = new SoftReference<Object>(obj);
	WeakReference<Object> wf = new WeakReference<Object>(obj);
	PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
	obj == null；//去掉强引用
## 垃圾收集 ##
#### 垃圾收集算法 ####
- 标记清除算法  
在标记阶段会判断是否有指向对象的引用，如果没有则标记对象。  
在回收阶段，回收对象并去除对象的标记，同时对象如果是连续的则会对对象空间进行合并。  
回收的实质是将需要回收的对象连接到一个空闲链表上。当进行分配的时候只要遍历这个空闲链表，找到空间大于等于要分配对象的分块即可。（空间大于时会进行链表的拆分，所以会产生内存碎片）。
- 标记整理算法  
标记阶段和标记清楚算法相同。  
标记完成后让所有存活对象向一端移动，移动完成后直接清除到边界之外的空间。  
不会产生内存碎片，但是移动对象的效率较低。
- 复制算法
将内存分为大小相同的两块，每次只使用其中的一块。当内存占满后将存活的对象直接复制到另一块上。
缺点是使内存变成了原来的一半大。  
现代的垃圾收集器都采用改进的复制算法来对新生代来进行回收。根据新生代对象存活时间短的特点，将内存分为1个 Eden 区和两个 Survivor，每次使用 Eden 和一块 Survivor，当回收时将对象复制到另一块 Survivor区。  
#### 垃圾收集器 ####
![](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/notes/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg)
垃圾收集器分为新生代收集器和老年代收集器两种。除了 CMS 和 G1 以外，所有的收集器都是串行执行的。  
Serial 是单线程的新生代收集器。
ParNew 是 Serial 的多线程版本。  
Parallel Scavenge 是多线程收集器，它的主要目标不是降低垃圾收集的停顿时间，而是尽可能的提高系统的吞吐率。  
Serial Old 是 Serial 收集器的老年代版本，采用标记复制算法。  
Parallel Old 是 Parallel Scavenge 收集器的老年代版本。  
CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。由于是并行执行的，所以在标记过程中，用户线程还可能会产生垃圾。标记 - 清除算法会产生内存碎片。  
G1  
## 内存分配和内存回收策略 ##
#### Minor GC 和 Full GC ####
Minor GC 回收新生代，因为新生代频繁发生，所以回收次数较多。  
Full GC 回收新生代和老年代，发生次数少。 只有老年代空间不足或分配担保策略失败时才会进行。 
#### 内存分配策略 ####
- 优先在新生代分配内存
- 大对象直接分配到老年代
- 年限足够的对象分配到老年代
- 动态对象年龄判断（Survivor 区中相同年龄对象的大小占 Survivor 区的一半以上则可以年龄大于等于该值的对象直接进入老年代）
- 空间分配担保（确保 Eden 和一个 Survivor 区的对象如果不能都存入另一个 Survivor 则存入 老年代）
## 类加载机制 ##
![](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/notes/pics/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png)  

加载：找到对象字节流，加载到方法区，并在堆中生成 Class 对象。  
验证：确定字节流符合规范。  
准备：为类变量、常量分配空间并初始化。如果是常量直接赋具体的值。  
解析：将.class 文件中的字面量解析成直接引用。  
初始化：初始化是执行 <clinit\>()方法的过程，它是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值。  

    public class Test {
	    static {
	        i = 0;                // 给变量赋值可以正常编译通过
	        System.out.print(i);  // 这句编译器会提示“非法向前引用”
	    }
	    static int i = 1;
	}